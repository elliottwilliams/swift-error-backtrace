import Foundation

#if UNSAFE_DEMANGLE
@_silgen_name("swift_demangle")
public
func _stdlib_demangleImpl(
  mangledName: UnsafePointer<CChar>?,
  mangledNameLength: UInt,
  outputBuffer: UnsafeMutablePointer<CChar>?,
  outputBufferSize: UnsafeMutablePointer<UInt>?,
  flags: UInt32
) -> UnsafeMutablePointer<CChar>?
#endif

private let kThrownCallStack = "SEBThrownCallStack"

public struct Backtrace: CustomStringConvertible {
  public var callStack: [UnsafeRawPointer]

  public var symbols: [String] {
    var info = Dl_info()
    let nameBuffer = UnsafeMutablePointer<Int8>.allocate(capacity: Int(MAXPATHLEN))
    defer { nameBuffer.deallocate() }
    #if UNSAFE_DEMANGLE
    let demangledSymbolBuffer = UnsafeMutablePointer<Int8>.allocate(capacity: Int(120))
    defer { demangledSymbolBuffer.deallocate() }
    #endif

    return callStack.enumerated().map { frameNumber, addr in
      guard dladdr(addr, &info) != 0 else {
        return String(format: "  %3d  ???", frameNumber)
      }
      let symbolAddress = UnsafeRawPointer(info.dli_saddr)!
      let frameOffset = symbolAddress.distance(to: addr)
      let frameworkName = OpaquePointer(basename_r(info.dli_fname, nameBuffer)!)
      #if UNSAFE_DEMANGLE
      var required_snamebuf_size: UInt = 120
//      _ = swift_demangle?(info.dli_sname, strlen(info.dli_sname), snamebuf, &required_snamebuf_size, 0)
      let demangledName = _stdlib_demangleImpl(
        mangledName: info.dli_sname,
        mangledNameLength: UInt(strlen(info.dli_sname)),
        outputBuffer: demangledSymbolBuffer,
        outputBufferSize: &required_snamebuf_size,
        flags: 0
      )
      let symbolName = demangledName ?? UnsafeMutablePointer(mutating: info.dli_sname!)
      #else
      let symbolName = info.dli_sname!
      #endif
      return String(format: "  %3d  %-33s %-16p %s + %d",
                    frameNumber, frameworkName, OpaquePointer(symbolAddress), symbolName, frameOffset)
    }
  }

  public var atos: [String] {
    let process = Process()
    let pipe = Pipe()
    process.launchPath = "/usr/bin/atos"
    process.arguments  = ["-p", String(ProcessInfo.processInfo.processIdentifier)] +
      callStack.map({ String(format: "%p", OpaquePointer($0)) })
    process.standardOutput = pipe
    process.launch()
    process.waitUntilExit()

    let atosLines = String(data: pipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8)?.split(separator: "\n")
    return atosLines?.enumerated().map({ String(format: "%5d  ", $0) + $1 }) ?? []
  }

  public var description: String {
    atos.joined(separator: "\n")
  }

  public static func capture<V>(from body: () throws -> V) throws -> V {
    do {
      return try body()
    } catch {
      let wrapper = CapturedBacktrace(error: error, backtrace: Thread.lastThrownErrorBacktrace!)
      throw wrapper
    }
  }

  struct CapturedBacktrace: Error, CustomStringConvertible {
    let error: Error
    let backtrace: Backtrace

    public var description: String {
      """
      \(error)

      Backtrace:
      \(backtrace)
      """
    }
  }
}

@_cdecl("swift_willThrow") // overshadow the call to swift_willThrow generated by the compiler
@inline(never)             // ensure a constant number of stack frames between the call to backtrace(3) and the throw
func swift_willThrow() {
  Thread.current.threadDictionary.setValue(
    Thread.callStackReturnAddresses[2...],
    forKey: kThrownCallStack
  )
}

extension Thread {
  static var lastThrownErrorBacktrace: Backtrace? {
    let returnAddresses = current.threadDictionary.value(forKey: kThrownCallStack) as! ArraySlice<NSNumber>?
    return returnAddresses.map { Backtrace(callStack: $0.map { UnsafeRawPointer(bitPattern: $0.uintValue)! }) }
  }
}
