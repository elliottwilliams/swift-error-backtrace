import Foundation

public struct Backtrace: CustomStringConvertible {
  public var callStack: [UnsafeRawPointer]

  public var symbols: [String] {
    var info = Dl_info()
    let nameBuffer = UnsafeMutablePointer<Int8>.allocate(capacity: Int(MAXPATHLEN))
    defer { nameBuffer.deallocate() }

    return callStack.enumerated().map { frameNumber, addr in
      guard dladdr(addr, &info) != 0 else {
        return String(format: "  %3d  ???", frameNumber)
      }
      let symbolAddress = UnsafeRawPointer(info.dli_saddr)!
      let frameOffset = symbolAddress.distance(to: addr)
      let frameworkName = OpaquePointer(basename_r(info.dli_fname, nameBuffer)!)
      let symbolName = info.dli_sname!
      return String(format: "  %3d  %-33s %-16p %s + %d",
                    frameNumber, frameworkName, OpaquePointer(symbolAddress), symbolName, frameOffset)
    }
  }

  public var debugSymbols: [String]? {
    let atosURL = URL(fileURLWithPath: "/usr/bin/atos")
    guard (try? atosURL.checkResourceIsReachable()) ?? false else {
      return nil
    }

    let process = Process()
    let pipe = Pipe()
    process.executableURL = atosURL
    process.arguments  = ["-p", String(ProcessInfo.processInfo.processIdentifier)] +
      callStack.map({ String(format: "%p", OpaquePointer($0)) })
    process.standardOutput = pipe
    process.launch()
    process.waitUntilExit()

    let atosLines = String(data: pipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8)?.split(separator: "\n")
    return atosLines?.enumerated().map({ String(format: "%5d  ", $0) + $1 }) ?? []
  }

  public var description: String {
    (debugSymbols ?? symbols).joined(separator: "\n")
  }

  public static func capture<V>(from body: () throws -> V) throws -> V {
    do {
      return try body()
    } catch {
      let wrapper = CapturedBacktrace(error: error, backtrace: Thread.lastThrownErrorBacktrace!)
      throw wrapper
    }
  }

  struct CapturedBacktrace: Error, CustomStringConvertible {
    let error: Error
    let backtrace: Backtrace

    public var description: String {
      """
      \(error)

      Backtrace:
      \(backtrace)
      """
    }
  }
}


private let kThrownCallStack = "swift-error-backtrace-ThrownCallStack"

@_cdecl("swift_willThrow") // overshadow the call to swift_willThrow generated by the compiler
@inline(never)             // ensure a constant number of stack frames between the call to backtrace(3) and the throw
func swift_willThrow() {
  Thread.current.threadDictionary.setValue(
    Thread.callStackReturnAddresses[2...],
    forKey: kThrownCallStack
  )
}

extension Thread {
  static var lastThrownErrorBacktrace: Backtrace? {
    let returnAddresses = current.threadDictionary.value(forKey: kThrownCallStack) as! ArraySlice<NSNumber>?
    return returnAddresses.map { Backtrace(callStack: $0.map { UnsafeRawPointer(bitPattern: $0.uintValue)! }) }
  }
}
